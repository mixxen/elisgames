<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dino Dusk: Pixel Hunt</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #121722;
      --panel-2: #0f1420;
      --ink: #e9eef7;
      --accent: #64d2ff;
      --accent-2: #8cff7a;
      --warning: #ffcc66;
      --danger: #ff6b6b;
      --ok: #54e1a6;
      --muted: #9fb2c7;
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: var(--bg); color: var(--ink);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      overflow: hidden;
    }
    #game { display: block; width: 100vw; height: 100vh; background: #000000; cursor: crosshair; }
    /* 3D fog implemented with translucent blocks in the scene */
    .hud {
      position: fixed; left: 12px; top: 12px; user-select: none; pointer-events: none;
      background: linear-gradient(180deg, rgba(18,23,34,.9), rgba(12,15,20,.8));
      border: 1px solid #1b2231; border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(4px);
      box-shadow: 0 4px 18px rgba(0,0,0,.25);
    }
    .hud h1 { margin:0 0 6px; font-size:16px; color: var(--accent); letter-spacing:.5px; }
    .row { display:flex; gap:10px; align-items:center; margin: 4px 0; }
    .pill {
      background: #0a101a; border: 1px solid #1b2231; border-radius: 999px; padding: 3px 8px;
      color: var(--muted); font-weight: 600; font-size: 12px; white-space: nowrap;
    }
    .bar { width: 220px; height: 8px; border-radius: 999px; background: #0a101a; border:1px solid #1b2231; overflow:hidden; }
    .bar>i { display:block;height:100%; background: linear-gradient(90deg, var(--accent), #9df3ff); width:0%; }
    .bar.health>i { background: linear-gradient(90deg, var(--ok), #b2fbd7); }
    .bar.boss>i { background: linear-gradient(90deg, var(--danger), #ff9b9b); }
    .key { display:inline-flex; align-items:center; justify-content:center; min-width:22px; padding:2px 6px; border-radius:6px;
           background:#0d1420; border:1px solid #1c2635; color:#c9d6ea; font-weight:700; font-size:12px; }
    #overlay { position: fixed; inset: 0; display:grid; place-items:center;
      background: radial-gradient(800px 600px at 50% 40%, rgba(20,26,38,.8), rgba(5,8,12,.9));
      transition: opacity .25s ease; z-index: 5;}
    #overlay.hidden { opacity: 0; pointer-events: none; }
    .card {
      width:min(92vw, 760px); background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid #1c2537; border-radius: 16px; padding: 22px 22px 16px; box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    .card h2 { margin:0 0 8px; font-size: 28px; color:#eaf5ff; letter-spacing:.3px; }
    .card p { color: var(--muted); margin:0 0 12px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .panel { border:1px solid #1b2231; border-radius:10px; padding:12px; background:#0b1019; }
    .cta { display:inline-flex; align-items:center; justify-content:center; gap:8px;
      background: linear-gradient(180deg, #0c5a7a, #093a4d); border: 1px solid #1b7ea4; color:#daf6ff; font-weight:800;
      letter-spacing:.4px; padding:10px 16px; border-radius:12px; cursor:pointer; user-select:none; text-decoration:none; }
    .cta-row { display:flex; gap:10px; margin-top: 14px; }
    .badge { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px;
      background:#0a101a; border:1px solid #1b2231; color:#b9c9de; font-weight:700; }
    #toast { position: fixed; right: 12px; top: 12px; display:flex; flex-direction: column; gap:8px; z-index: 6; }
    .toast { background:#0a101a; border:1px solid #1b2231; border-left:4px solid var(--accent);
      padding: 8px 10px; border-radius:8px; color:#cfe4ff; min-width:220px; box-shadow:0 6px 20px rgba(0,0,0,.2); }
    .toast.warn { border-left-color: var(--warning); }
    .toast.danger { border-left-color: var(--danger); }
    .footnote { color:#8aa2c0; font-size:12px; }
    .bday-banner { position: fixed; left: 0; right: 0; top: 25%; text-align: center;
      font-weight: 900; letter-spacing: .8px; font-size: clamp(24px, 6vw, 72px);
      color: #ffe9a8; text-shadow: 0 6px 30px rgba(0,0,0,.45);
      opacity: 0; pointer-events: none; transition: opacity 1s ease; z-index: 7; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud" id="hud">
    <h1>Dino Dusk</h1>
    <div class="row">
      <span class="pill">Day <b id="day">1</b></span>
      <span class="pill">Kills <b id="kills">0</b></span>
      <span class="pill">Score <b id="score">0</b></span>
      <span class="pill">Grenades <b id="grenades">1</b></span>
      <span class="pill">Machine Lvl <b id="machlvl">1</b></span>
      <span class="pill">Shotgun Lvl <b id="shotlvl">0</b></span>
      <span class="pill">Missile Lvl <b id="misslvl">0</b></span>
    </div>
    <div class="row" title="Time until boss">
      <div class="bar" style="width:260px"><i id="daybar"></i></div>
      <span class="pill">‚åõ <b id="timeleft">60s</b></span>
    </div>
      <div class="row" title="Your health">
        <div class="bar health"><i id="hpbar"></i></div>
        <span class="pill">HP <b id="hptext">100</b></span>
      </div>
      <div class="row" title="Special attack charge">
        <div class="bar" style="width:220px"><i id="spbar"></i></div>
        <span class="pill">Special</span>
      </div>
      <div class="row" id="bossRow" style="display:none" title="Boss health">
        <div class="bar boss" style="width:260px"><i id="bossbar"></i></div>
        <span class="pill">Boss</span>
      </div>
    <div class="row" style="gap:6px; margin-top: 6px; pointer-events: auto;">
      <span class="badge"><span class="key">WASD</span>/<span class="key">‚Üë‚Üì‚Üê‚Üí</span> Move</span>
      <span class="badge"><span class="key">Mouse</span> Aim</span>
      <span class="badge"><span class="key">L‚ÄëClick</span> Shoot</span>
      <span class="badge"><span class="key">G</span>/<span class="key">R‚ÄëClick</span> Grenade</span>
      <span class="badge"><span class="key">P</span> Pause</span>
    </div>
  </div>

  <div id="overlay">
    <div class="card">
      <h2>Survive the Night. Hunt at Dawn.</h2>
      <p>WASD or arrows to move, aim with mouse, <b>left‚Äëclick</b> to shoot. Pick up crates for <b>grenades</b> &amp; <b>gun upgrades</b>. Beat the <b>T‚ÄëRex</b> boss at the end of each day to advance.</p>
      <div class="grid">
        <div class="panel">
          <b>Objective</b>
          <ul>
            <li>Survive raptors &amp; pterodactyls.</li>
            <li>Day ends ‚Üí <b>T‚ÄëRex boss</b>.</li>
            <li>Win to start a harder next day.</li>
          </ul>
        </div>
        <div class="panel">
          <b>Supplies</b>
          <ul>
            <li><b>Grenade Crate:</b> +1‚Äì2 grenades.</li>
            <li><b>Gun Upgrade:</b> faster fire &amp; more damage (max 5).</li>
            <li><b>Shotgun Upgrade:</b> more pellets (max 10).</li>
          </ul>
        </div>
      </div>
      <div class="cta-row">
        <button id="btnStart" class="cta">‚ñ∂ Start</button>
        <button id="btnMute" class="cta" title="Mute/Unmute (M)">üîà Mute</button>
        <button id="btnFS" class="cta" title="Fullscreen">‚õ∂ Fullscreen</button>
      </div>
      <p class="footnote" style="margin-top:8px">Tip: Right‚Äëclick throws a grenade. High score is saved locally.</p>
    </div>
  </div>

  <div id="toast"></div>

  <script type="module">
    import { Scenery, generateScenery, scrollScenery } from './scenery.js';
    import { createRaptorClass } from './raptor.js';
    import { createProjectileClasses } from './projectiles.js';
    import { createMeteorClass, specialBarColor } from './special.js';
    import { createAudioBus } from './audio.js';
    import { Renderer3D } from './renderer3d.js';
  const version = await fetch('./package.json').then(r=>r.json()).then(p=>p.version).catch(()=>null);
  if (version) {
    document.title = `Dino Dusk v${version}: Pixel Hunt`;
    document.querySelector('#hud h1').textContent = `Dino Dusk v${version}`;
  }
  // ===== Dino Dusk ‚Äî Pixel edition =====

  // -------------------------
  // Utilities
  // -------------------------
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const choice = (arr) => arr[(Math.random() * arr.length) | 0];
  const now = () => performance.now();

  const CELEBRATION_COLORS = ['#ff5f5f','#ffd166','#06d6a0','#118ab2','#ef476f','#8ecae6','#f4a261','#e9c46a','#2a9d8f','#ff9b9b','#b2ff9f'];
  function randBrightColor() {
    return choice(CELEBRATION_COLORS);
  }

  function spawnParticles(game, x, y, opts = {}) {
    const {
      angle = 0,
      spread = Math.PI / 8,
      count = 4,
      speed = [60, 140],
      life = [0.12, 0.25],
      colors = ['#ffffff'],
      size = [1.4, 2.4]
    } = opts;
    for (let i = 0; i < count; i++) {
      const ang = angle + rand(-spread, spread);
      const vel = Vec2.fromAngle(ang, rand(speed[0], speed[1]));
      const col = Array.isArray(colors) ? choice(colors) : colors;
      const lifeSpan = Array.isArray(life) ? rand(life[0], life[1]) : life;
      const radius = Array.isArray(size) ? rand(size[0], size[1]) : size;
      game.particles.push(new Particle(x, y, vel, lifeSpan, col, radius));
    }
  }

  function isEliBirthday() {
    try {
      const d = new Date();
      return d.getMonth() === 8 && d.getDate() === 24; // September 24
    } catch { return false; }
  }

  const GROUND_TILE_SIZE = 64;
  const GROUND_SEED = Math.floor(Math.random() * 1e9);

  function hashNoise(seed, x, y) {
    let n = seed ^ (x * 374761393) ^ (y * 668265263);
    n = (n ^ (n >> 13)) * 1274126177;
    n = (n ^ (n >> 16)) >>> 0;
    return n / 4294967295;
  }

  function groundTypeForEnv(env, col, row) {
    const noise = hashNoise(GROUND_SEED, col, row);
    switch (env) {
      case 'forest':
      case 'land':
        return noise < 0.08 ? 'sand' : 'grass';
      case 'sand':
        return 'sand';
      case 'water':
        return 'water';
      case 'transition':
        return noise < 0.33 ? 'grass' : noise < 0.66 ? 'sand' : 'water';
      default:
        return 'grass';
    }
  }

  function createGroundTiles(env, width, height, startCol = -1, resolver = groundTypeForEnv) {
    const cols = Math.ceil(width / GROUND_TILE_SIZE) + 2;
    const rows = Math.ceil(height / GROUND_TILE_SIZE) + 2;
    const startRow = -1;
    const tiles = [];
    for (let row = 0; row < rows; row++) {
      const rowTiles = [];
      const worldRow = startRow + row;
      for (let col = 0; col < cols; col++) {
        const worldCol = startCol + col;
        const type = resolver ? resolver(env, worldCol, worldRow) : groundTypeForEnv(env, worldCol, worldRow);
        rowTiles.push({ colIndex: col, rowIndex: row, worldCol, worldRow, type });
      }
      tiles.push(rowTiles);
    }
    return { env, startCol, startRow, cols, rows, tiles };
  }

  class Vec2 {
    constructor(x=0, y=0) { this.x = x; this.y = y; }
    copy() { return new Vec2(this.x, this.y); }
    set(x,y){ this.x=x; this.y=y; return this; }
    add(v){ this.x+=v.x; this.y+=v.y; return this; }
    sub(v){ this.x-=v.x; this.y-=v.y; return this; }
    scale(s){ this.x*=s; this.y*=s; return this; }
    len(){ return Math.hypot(this.x, this.y); }
    norm(){ const l=this.len()||1; this.x/=l; this.y/=l; return this; }
    angle(){ return Math.atan2(this.y, this.x); }
    static fromAngle(a, mag=1){ return new Vec2(Math.cos(a)*mag, Math.sin(a)*mag); }
  }

  // -------------------------
  // Config
  // -------------------------
  const CONFIG = {
    dayLength: 60,
    baseSpawnInterval: 1.6,
    raptorBias: 0.68,
    supplyEveryMinMax: [8, 16],
    worldMargin: 80,
    scrollSpeed: 40,
    specialChargeRequired: 30,
    player: {
      radius: 16, speed: 240, maxHP: 100, invuln: 0.7,
      baseFireRate: 4, baseBulletDamage: 15, bulletSpeed: 540,
      fireRatePerLevel: 1.0, dmgPerLevel: 5, maxMachineLevel: 10,
      shotgunFireRate: 0.6, maxShotgunLevel: 10, maxMissileLevel: 10,
      grenadeFuse: 0.85, grenadeRadius: 160, grenadeDamage: 140, grenadeSpeed: 420, missileCooldown: 5,
    },
    enemies: {
      raptor: { speed: [110, 160], radius: 18, hp: 32, dmg: 12 },
      ptero:  { speed: [140, 200], radius: 16, hp: 24, dmg: 10 },
      trex:   { speed: [90, 160],  radius: 42, hp: 950, dmg: 28, chargeEvery: [2.2, 3.8], chargeBoost: 2.2 }
    },
    difficultyPerDay: { hp: 1.18, speed: 1.10, dmg: 1.12, spawnRate: 1.14 },
  };

  const SPECIAL_CHARGE_REQUIRED = Math.max(CONFIG.specialChargeRequired ?? 30, 1);

  const SCENE_SEQUENCE = ['forest', 'sand', 'water', 'sand'];
  const SCENE_DURATION = 60;
  const FOREST_TREE_PROB = 0.15;

  const TREE_COLLISION_RADIUS = 36;

  // -------------------------
  // Canvas
  // -------------------------
  const canvas = document.getElementById('game');
  const renderer3D = new Renderer3D(canvas);

  let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const Input = { keys:new Set(), mouse:new Vec2(), mdown:false, rdown:false, gdown:false, special:false };
  let game = null;
  let lastMouseClient = null;
  const updateMouseFromClient = (clientX, clientY) => {
    const rect = canvas.getBoundingClientRect();
    const sx = (clientX - rect.left) * DPR;
    const sy = (clientY - rect.top) * DPR;
    lastMouseClient = { x: clientX, y: clientY };
    const world = renderer3D.screenToWorld(sx, sy);
    Input.mouse.set(world.x, world.y);
  };
  function resize() {
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const w = window.innerWidth, h = window.innerHeight;
    renderer3D.setSize(Math.floor(w * DPR), Math.floor(h * DPR));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    if (lastMouseClient) {
      updateMouseFromClient(lastMouseClient.x, lastMouseClient.y);
    } else {
      const rect = canvas.getBoundingClientRect();
      updateMouseFromClient(rect.left + rect.width / 2, rect.top + rect.height / 2);
    }
    if (game) {
      game.handleResize(canvas.width, canvas.height);
    }
  }
  resize();
  window.addEventListener('resize', resize);
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // -------------------------
  // Input
  // -------------------------
  const keymap = (e) => e.key.length===1 ? e.key.toLowerCase() : e.key;
  window.addEventListener('keydown', (e) => {
    const k = keymap(e);
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    Input.keys.add(k);
    if (k==='p') togglePause();
    if (k==='m') toggleMute();
    if (k==='g' && !e.repeat) Input.gdown = true;
    if (k==='r' && !e.repeat) {
      if (game.state==='running') Input.special = true; else restart();
    }
  });
  window.addEventListener('keyup', (e) => {
    const k = keymap(e);
    Input.keys.delete(k);
    if (k==='g') Input.gdown = false;
    if (k==='r') Input.special = false;
  });
  canvas.addEventListener('mousedown', (e) => {
    if (e.button===0) Input.mdown = true;
    if (e.button===2) { Input.rdown = true; Input.gdown = true; }
    updateMouseFromClient(e.clientX, e.clientY);
  });
  window.addEventListener('mouseup',   (e) => { if (e.button===0) Input.mdown = false; if (e.button===2) Input.rdown = false; });
  canvas.addEventListener('mousemove', (e) => {
    updateMouseFromClient(e.clientX, e.clientY);
  });

  // -------------------------
  // Audio (tiny synth)
  // -------------------------
  const AudioBus = createAudioBus();
  function toggleMute(){
    AudioBus.muted = !AudioBus.muted;
    showToast(AudioBus.muted ? 'Muted' : 'Unmuted');
    document.getElementById('btnMute').textContent = AudioBus.muted ? 'üîá Unmute' : 'üîà Mute';
  }

  // -------------------------
  // Pixel art sprites
  // -------------------------
  const Sprites = {};
  function makeSprite(w, h, painter){
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const s = c.getContext('2d'); s.imageSmoothingEnabled = false;
    painter(s, w, h);
    return c;
  }
  function px(ctx, x,y, color){ ctx.fillStyle = color; ctx.fillRect(x,y,1,1); }

  // Player (24x24)
  Sprites.player = makeSprite(24,24,(s,w,h)=>{
    const skin = '#f4d7c5', hair='#3a2a1a';
    for (let i=0;i<6;i++) px(s, 15+i, 3, hair);
    for (let y=4;y<=7;y++) for (let x=14;x<=20;x++) px(s,x,y, skin);
    px(s, 17,6,'#000');
    const jacket='#3ec4ff', shirt='#bfe9ff', outline='#152033', pants='#22334a', boots='#0d121a';
    s.fillStyle = outline; s.fillRect(5,8,14,1);
    s.fillStyle = jacket; s.fillRect(6,9,12,9);
    s.fillStyle = shirt;  s.fillRect(10,10,4,4);
    s.fillStyle = jacket; s.fillRect(4,10,3,6); s.fillRect(18,10,3,6);
    s.fillStyle = '#d2e8ff'; s.fillRect(16,11,6,3); s.fillRect(20,9,3,7);
    s.fillStyle = pants; s.fillRect(8,18,4,4); s.fillRect(12,18,4,4);
    s.fillStyle = boots; s.fillRect(8,22,4,2); s.fillRect(12,22,4,2);
  });

  // Raptor (24x24)
  Sprites.raptor = makeSprite(24,24,(s)=>{
    const body='#4ecf63', belly='#a7f0b2';
    s.fillStyle = body; s.fillRect(2,12,6,2); s.fillRect(6,11,4,4);
    s.fillStyle = body; s.fillRect(9,9,9,8);
    s.fillStyle = belly; s.fillRect(11,12,6,3);
    s.fillStyle = body; s.fillRect(17,8,5,5);
    px(s, 20,9,'#fff'); px(s, 20,10,'#fff'); px(s,21,10,'#000');
    s.fillStyle = '#2a3c2f'; s.fillRect(11,17,3,3); s.fillRect(15,17,3,3);
    s.fillStyle = '#eee'; px(s, 11,20,'#eee'); px(s, 16,20,'#eee');
  });

  // Water Dino (24x24)
  // Serpentine water creature without feet
  Sprites.waterdino = makeSprite(24,24,(s)=>{
    const body='#5ab4ff', belly='#bfe9ff', fin='#3d94d9';
    s.fillStyle = body; s.fillRect(2,12,20,4); // long body
    s.fillRect(2,14,4,4); // tail curve
    s.fillRect(16,8,4,4); // neck
    s.fillRect(18,4,4,4); // head
    s.fillStyle = belly; s.fillRect(4,13,12,2); // underside
    s.fillStyle = fin; s.fillRect(8,8,4,4); // dorsal fin
    px(s,19,5,'#fff'); px(s,20,5,'#000'); // eye
  });

  // Pterodactyl (24x24)
  Sprites.ptero = makeSprite(24,24,(s)=>{
    const wing='#9ddcff', body='#6bb4e6';
    s.fillStyle = wing;
    s.beginPath(); s.moveTo(2,12); s.lineTo(10,6); s.lineTo(10,12); s.closePath(); s.fill();
    s.beginPath(); s.moveTo(22,12); s.lineTo(14,6); s.lineTo(14,12); s.closePath(); s.fill();
    s.fillStyle = body; s.fillRect(10,10,4,5);
    s.fillStyle = body; s.fillRect(14,9,4,2); s.fillRect(18,9,3,1);
    px(s, 15,9,'#001a33');
  });

  // T-Rex (48x48)
  Sprites.trex = makeSprite(48,48,(s)=>{
    const body='#ff6b6b', belly='#ffd0d0', dark='#2a0613';
    s.fillStyle = body; s.fillRect(8,16,28,18);
    s.fillStyle = belly; s.fillRect(14,22,16,6);
    s.fillStyle = body; s.fillRect(30,12,12,12);
    s.fillStyle = dark; s.fillRect(39,14,3,3);
    s.fillStyle = dark; s.fillRect(30,18,12,4);
    s.fillStyle = '#7a2633'; s.fillRect(16,32,6,6); s.fillRect(26,32,6,6);
    s.fillStyle = '#fff1f1'; s.fillRect(16,38,3,2); s.fillRect(29,38,3,2);
    s.fillStyle = body; s.fillRect(2,20,8,6);
  });

  // Mosasaurus (48x48)
  // Aquatic boss with long mouth, fins and tail
  Sprites.mosasaurus = makeSprite(48,48,(s)=>{
    const body='#5ab4ff', belly='#bfe9ff', dark='#103b5b';
    s.fillStyle = body; s.fillRect(4,20,34,10); // main body
    s.fillRect(0,22,8,6); // tail
    s.fillRect(38,18,10,6); // head and long mouth
    s.fillStyle = dark; s.fillRect(42,19,6,2); // mouth line
    s.fillStyle = belly; s.fillRect(8,24,26,4); // underside
    s.fillStyle = body; s.fillRect(14,30,8,4); s.fillRect(26,30,8,4); // fins
    s.fillStyle = '#fff'; s.fillRect(44,20,2,2); s.fillStyle='#000'; s.fillRect(45,20,1,1); // eye
  });

  // Bullet & Grenade
  Sprites.bullet = makeSprite(4,4,(s)=>{ s.fillStyle='#e8f5ff'; s.beginPath(); s.arc(2,2,2,0,Math.PI*2); s.fill(); });
  Sprites.grenade = makeSprite(8,8,(s)=>{
    s.fillStyle = '#8a6b2c'; s.fillRect(2,1,2,2);
    s.fillStyle = '#ffd36b'; s.fillRect(1,3,6,4);
  });
  Sprites.meteor = makeSprite(24,24,(s)=>{ s.fillStyle='#ff944d'; s.beginPath(); s.arc(12,12,12,0,Math.PI*2); s.fill(); });
  // Balloon sprite for birthday mode
  Sprites.balloon = makeSprite(10,16,(s)=>{
    const col = '#ff4d7a';
    s.fillStyle = col; s.beginPath(); s.arc(5,6,5,0,Math.PI*2); s.fill();
    s.fillStyle = '#e83366'; s.beginPath(); s.arc(4,5,2.6,0,Math.PI*2); s.fill();
    s.strokeStyle = '#c0c0c0'; s.lineWidth = 1; s.beginPath(); s.moveTo(5,11); s.lineTo(5,16); s.stroke();
  });
  Sprites.crateGren = makeSprite(14,14,(s)=>{
    s.fillStyle='#101824'; s.fillRect(0,0,14,14);
    s.strokeStyle='#203049'; s.lineWidth=2; s.strokeRect(1,1,12,12);
    s.fillStyle='#ffd36b'; s.fillRect(5,6,4,4);
  });
  Sprites.crateGun = makeSprite(14,14,(s)=>{
    s.fillStyle='#101824'; s.fillRect(0,0,14,14);
    s.strokeStyle='#203049'; s.lineWidth=2; s.strokeRect(1,1,12,12);
    s.fillStyle='#64d2ff'; s.fillRect(3,6,8,2); s.fillRect(8,4,3,6);
  });
  Sprites.crateShot = makeSprite(14,14,(s)=>{
    s.fillStyle='#101824'; s.fillRect(0,0,14,14);
    s.strokeStyle='#203049'; s.lineWidth=2; s.strokeRect(1,1,12,12);
    s.fillStyle='#ff64d2'; s.fillRect(3,6,8,2); s.fillRect(8,4,3,6);
  });
  Sprites.crateMiss = makeSprite(14,14,(s)=>{
    s.fillStyle='#101824'; s.fillRect(0,0,14,14);
    s.strokeStyle='#203049'; s.lineWidth=2; s.strokeRect(1,1,12,12);
    s.fillStyle='#64ff64'; s.fillRect(3,6,8,2); s.fillRect(8,4,3,6);
  });

  function createVoxelModel(voxelSize, builder) {
    const map = new Map();
    const key = (x, y, z) => `${x},${y},${z}`;
    let baseRotation = { x: 0, y: 0, z: 0 };
    let dynamic = true;
    const set = (x, y, z, color) => { map.set(key(x, y, z), { x, y, z, color }); };
    const fill = (xs, ys, zs, color) => {
      for (const x of xs) for (const y of ys) for (const z of zs) set(x, y, z, color);
    };
    builder({ set, fill, setBaseRotation: (rot) => {
      baseRotation = {
        x: Number(rot?.x) || 0,
        y: Number(rot?.y) || 0,
        z: Number(rot?.z) || 0,
      };
    }, setDynamic: (flag) => { dynamic = !!flag; }});
    return { voxelSize, voxels: Array.from(map.values()), baseRotation, dynamic };
  }

  const PLAYER_VOXEL_MODEL = createVoxelModel(4, ({ fill, set }) => {
    // Boots & legs
    fill([-1, 1], [-1, 0], [0], '#0d121a');
    fill([-1, 1], [-1, 0], [1], '#22334a');
    fill([-1, 0, 1], [-1, 0], [2], '#22334a');

    // Torso
    fill([-1, 0, 1], [-1, 0], [3, 4], '#3ec4ff');
    fill([-1, 0, 1], [-1, 0], [5], '#3ec4ff');
    set(0, -1, 4, '#bfe9ff');
    set(1, -1, 3, '#bfe9ff');

    // Arms
    fill([-2, 2], [-1, 0], [3, 4], '#3ec4ff');
    set(-2, -1, 3, '#f4d7c5');
    set(2, -1, 3, '#f4d7c5');

    // Neck & head
    fill([0], [-1, 0], [5], '#f4d7c5');
    fill([-1, 0, 1], [-1, 0], [6, 7], '#f4d7c5');
    set(1, -1, 6, '#000000');

    // Hair
    fill([-1, 0, 1], [-1, 0], [8], '#3a2a1a');
    fill([-1, 0, 1], [0], [7], '#3a2a1a');
  });

  const RAPTOR_VOXEL_MODEL = createVoxelModel(3, ({ fill, set }) => {
    const scales = '#4ecf63', belly = '#a7f0b2', claw = '#1b2433', eye = '#f4f8ff', pupil = '#000000';
    // Tail - long and tapered
    fill([-6, -5, -4], [-1, 0], [1], scales);
    fill([-6], [-1, 0], [0], scales);
    fill([-3, -2], [-1, 0], [1, 2], scales);
    // Body core with slightly arched back
    fill([-1, 0, 1], [-1, 0], [1, 2], scales);
    fill([-1, 0], [-1, 0], [2], belly);
    // Chest / shoulder bulge
    fill([2], [-1, 0], [2], scales);
    set(2, -1, 2, belly);
    // Neck and head angled forward
    fill([2, 3], [-1, 0], [2, 3], scales);
    set(3, -1, 3, eye);
    set(3, -1, 2, pupil);
    // Snout tip / jaw
    fill([4], [-1, 0], [2], scales);
    set(4, -1, 2, pupil);
    // Arms tucked in front
    fill([1, 2], [-1, 0], [3], scales);
    set(2, -1, 3, claw);
    set(2, 0, 3, claw);
    // Powerful legs
    fill([0, 1], [-1, 0], [0], claw);
    fill([-1, -2], [-1, 0], [0], claw);
    // Head crest accent
    set(2, 0, 3, scales);
  });

  const WATER_VOXEL_MODEL = createVoxelModel(4, ({ fill, set }) => {
    const body = '#5ab4ff', belly = '#bfe9ff', fin = '#3d94d9';
    fill([-3, -2, -1, 0, 1, 2, 3, 4], [-1, 0], [1, 2], body);
    fill([4, 5], [-1, 0], [2], body);
    fill([-1, 0, 1, 2], [-1, 0], [1], belly);
    fill([0, 1], [-1, 0], [3], fin);
    fill([-2, -3], [-1, 0], [3], fin);
    set(5, -1, 2, '#ffffff');
    set(5, -1, 1, '#000000');
  });

  // Simple low-poly boat the player stands in when on water
  const BOAT_VOXEL_MODEL = createVoxelModel(4, ({ fill, set, setDynamic }) => {
    setDynamic(false);
    const hull = '#6b3f1f';
    const rim = '#8b5a2b';
    const deck = '#b78b5e';
    // Base hull
    fill([-4,-3,-2,-1,0,1,2,3,4], [-2,-1,0,1,2], [0], hull);
    // Sides (rim)
    fill([-4,-3,-2,-1,0,1,2,3,4], [-2,2], [1], rim);
    fill([-4,4], [-2,-1,0,1,2], [1], rim);
    // Deck slightly raised inside
    fill([-3,-2,-1,0,1,2,3], [-1,0,1], [1], deck);
    // Small bow tip
    set(4, 0, 2, rim);
    set(-4, 0, 2, rim);
  });

  const PTERO_VOXEL_MODEL = createVoxelModel(3, ({ fill, set, setBaseRotation }) => {
    const spar = '#9ddcff', membrane = '#6bb4e6', body = '#4b7fb3', beak = '#2f4f7a', claw = '#1f2533', eye = '#001a33';
    setBaseRotation({ x: -Math.PI / 11, y: 0, z: 0 });

    // Body spine and tail aligned with flight direction (positive X)
    fill([-6, -5, -4, -3, -2, -1, 0], [-1, 0], [0], body);
    fill([-8, -7], [-1, 0], [0], membrane);

    // Head, crest & beak extending forward
    fill([1, 2], [-1, 0], [0], body);
    fill([2, 3, 4, 5, 6, 7], [-1, 0], [0], beak);
    fill([4, 5, 6], [-1, 0], [-1], membrane);
    set(4, -1, 0, eye);
    set(4, 0, 0, eye);
    set(7, -1, 0, '#d2e6ff');
    set(5, -1, 1, body);

    // Wings: tapered triangle with thicker root near body
    const maxSpan = 6;
    for (let y = -maxSpan; y <= maxSpan; y++) {
      const absY = Math.abs(y);
      const back = Math.max(1, 3 - Math.floor(absY / 2));
      const forward = Math.max(0, 1 - Math.floor(absY / 3));
      const sparXs = [];
    for (let dx = -back; dx <= forward; dx++) sparXs.push(dx);
      fill(sparXs, [y], [0], spar);

      if (forward > 0) {
        set(forward, y, 0, '#c7e3ff');
      }

      if (back > 1 || forward > 0) {
        const innerXs = [];
        for (let dx = -back + 1; dx <= forward - 1; dx++) innerXs.push(dx);
        if (innerXs.length > 0) {
          const zLayer = absY <= 1 ? 1 : absY <= 3 ? 0 : -1;
          fill(innerXs, [y], [zLayer], membrane);
        }
      }
    }

    // Feet tucked under
    set(-1, -1, -1, claw);
    set(-1, 0, -1, claw);
    set(0, -1, -1, claw);
    set(0, 0, -1, claw);
  });

  const TREX_VOXEL_MODEL = createVoxelModel(6, ({ fill, set }) => {
    const body = '#ff6b6b', belly = '#ffd0d0', dark = '#2a0613', eye = '#000000', tooth = '#ffe4e4';
    // Tail ‚Äî long and narrow tapering back
    fill([-9, -8], [-1, 0], [2], body);
    fill([-7, -6, -5], [-1, 0], [2, 3], body);
    fill([-7], [-1, 0], [1], body);

    // Powerful hips and torso
    fill([-4, -3, -2, -1, 0, 1, 2], [-1, 0], [2, 3], body);
    fill([-2, -1, 0], [-1, 0], [1], body);
    fill([-1, 0, 1], [-1, 0], [2], belly);

    // Massive head with jaw
    fill([3, 4, 5], [-1, 0], [3, 4], body);
    fill([5, 6], [-1, 0], [3, 4], body);
    fill([4, 5, 6], [-1, 0], [2], belly);
    fill([4, 5, 6], [-1, 0], [1], belly);
    set(6, -1, 3, eye);
    set(5, -1, 4, eye);
    set(6, -1, 2, tooth);
    set(6, 0, 2, tooth);

    // Lower jaw depth
    set(5, -1, 1, dark);
    set(5, 0, 1, dark);

    // Tiny arms tucked near chest
    set(2, -1, 3, body);
    set(2, -1, 2, dark);
    set(2, 0, 2, dark);

    // Powerful legs and feet
    fill([-2, -1], [-1, 0], [0, 1], dark);
    fill([0, 1], [-1, 0], [0, 1], dark);
    set(-1, -1, -1, dark);
    set(1, -1, -1, dark);
  });

  const MOSA_VOXEL_MODEL = createVoxelModel(6, ({ fill, set }) => {
    const body = '#5ab4ff', belly = '#bfe9ff', dark = '#103b5b';
    fill([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4], [-1, 0], [2, 3], body);
    fill([4, 5, 6], [-1, 0], [2], body);
    fill([-2, -1, 0, 1, 2], [-1, 0], [1], belly);
    fill([2, 3, 4], [-1, 0], [3], dark);
    set(6, -1, 2, '#ffffff');
    set(6, -1, 3, '#000000');
  });

  const TREE_OAK_VOXEL_MODEL = createVoxelModel(4, ({ fill, set, setDynamic }) => {
    setDynamic(false);
    const trunk = '#6f4424';
    const leaves = '#2f7d31';
    const highlight = '#4ea54a';
    fill([-1, 0], [-1, 0], [0, 1, 2, 3, 4], trunk);
    for (const z of [5, 6, 7]) {
      fill([-3, -2, -1, 0, 1, 2, 3], [-3, -2, -1, 0, 1, 2, 3], [z], leaves);
    }
    fill([-2, -1, 0, 1, 2], [-2, -1, 0, 1, 2], [8], highlight);
    fill([-3, -2, -1, 0, 1, 2, 3], [-3, -2, -1, 0, 1, 2, 3], [4], leaves);
  });

  const TREE_PINE_VOXEL_MODEL = createVoxelModel(4, ({ fill, set, setDynamic }) => {
    setDynamic(false);
    const trunk = '#5b3a1a';
    const needles = '#1f5d2d';
    fill([-1, 0], [-1, 0], [0, 1, 2, 3, 4], trunk);
    let width = 4;
    for (let z = 5; z <= 11; z++) {
      const xs = [];
      for (let dx = -width; dx <= width; dx++) xs.push(dx);
      fill(xs, [-width, -width + 1, width - 1, width], [z], needles);
      fill(xs, [ -width + 1, -width + 2, width - 2, width - 1], [z], needles);
      width = Math.max(1, width - 1);
    }
    set(0, 0, 12, '#2f8748');
  });

  const TREE_BIRCH_VOXEL_MODEL = createVoxelModel(4, ({ fill, set, setDynamic }) => {
    setDynamic(false);
    const trunk = '#e8e8e8';
    const bark = '#2f2f2f';
    const canopy = '#5fae4a';
    fill([-1, 0], [-1, 0], [0, 1, 2, 3, 4], trunk);
    set(-1, -1, 1, bark); set(0, 0, 2, bark); set(-1, 0, 3, bark);
    fill([-2, -1, 0, 1], [-2, -1, 0, 1], [5, 6, 7], canopy);
    fill([-1, 0], [-1, 0], [8], '#7fdc6a');
  });

  const ROCK_VOXEL_MODEL = createVoxelModel(3, ({ fill, set, setDynamic }) => {
    setDynamic(false);
    const base = '#65707f';
    const highlight = '#a4b1c2';
    fill([-1, 0], [-1, 0], [0, 1], base);
    fill([-2, -1, 0, 1], [-2, -1, 0, 1], [1, 2], base);
    fill([-1, 0], [-1, 0], [3], highlight);
    set(-2, -1, 1, highlight);
    set(1, 0, 2, highlight);
  });

  const SCENERY_MODELS = {
    tree_oak: { model: TREE_OAK_VOXEL_MODEL, scale: 3.2, radius: 42 },
    tree_pine: { model: TREE_PINE_VOXEL_MODEL, scale: 3.4, radius: 46 },
    tree_birch: { model: TREE_BIRCH_VOXEL_MODEL, scale: 3.0, radius: 38 },
    rock: { model: ROCK_VOXEL_MODEL, scale: 2.4, radius: 24 }
  };

  const VOXEL_MODELS = {
    player: PLAYER_VOXEL_MODEL,
    raptor: RAPTOR_VOXEL_MODEL,
    water: WATER_VOXEL_MODEL,
    ptero: PTERO_VOXEL_MODEL,
    trex: TREX_VOXEL_MODEL,
    mosasaurus: MOSA_VOXEL_MODEL,
    boat: BOAT_VOXEL_MODEL
  };

  Sprites.grass = makeSprite(12,6,(s)=>{
    s.fillStyle='#1e5d2b'; s.fillRect(0,3,12,3);
    s.fillStyle='#2f7d31'; s.fillRect(2,1,8,4);
  });
  Sprites.tree = makeSprite(20,24,(s)=>{
    s.fillStyle='#4d3218'; s.fillRect(8,10,4,14);
    s.fillStyle='#1e5d2b'; s.beginPath(); s.arc(10,8,8,0,Math.PI*2); s.fill();
  });
  Sprites.rock = makeSprite(14,10,(s)=>{
    s.fillStyle='#505762'; s.beginPath(); s.moveTo(3,0); s.lineTo(11,0); s.lineTo(14,6); s.lineTo(11,10); s.lineTo(3,10); s.lineTo(0,4); s.closePath(); s.fill();
  });

  Sprites.beach = makeSprite(12,6,(s)=>{ s.fillStyle='#f4e7b6'; s.fillRect(0,0,12,6); });
  Sprites.whitewash = makeSprite(16,8,(s)=>{ s.fillStyle='#ffffff'; s.beginPath(); s.arc(8,4,4,0,Math.PI*2); s.fill(); });
  Sprites.wave = makeSprite(20,10,(s)=>{ s.fillStyle='#5ab4ff'; s.beginPath(); s.arc(10,10,10,Math.PI,0); s.fill(); });

  // -------------------------
  // Entities
  // -------------------------
  class Entity {
    constructor(x, y, r=12) { this.pos = new Vec2(x,y); this.z = 0; this.vel = new Vec2(0,0); this.radius = r; this.hp = 1; this.alive = true; }
    update(dt, game) {}
    damage(d) { this.hp -= d; if (this.hp <= 0) this.alive = false; }
    draw(ctx, game) {}
  }

  class Player extends Entity {
    constructor(x, y){
      super(x,y, CONFIG.player.radius);
      this.maxHP = CONFIG.player.maxHP; this.hp = this.maxHP;
      this.speed = CONFIG.player.speed; this.invuln = 0;
      this.shootCD = 0; this.shotgunCD = 0; this.missileCD = 0; this.machineLevel = 1; this.shotgunLevel = 0; this.missileLevel = 0; this.grenades = 1;
      this.aim = new Vec2(1,0); this.score = 0; this.kills = 0;
    }
    get fireRate(){
      return CONFIG.player.baseFireRate + (this.machineLevel-1)*CONFIG.player.fireRatePerLevel;
    }
    get bulletDamage(){ return CONFIG.player.baseBulletDamage + (this.machineLevel-1)*CONFIG.player.dmgPerLevel; }
    get shotgunFireRate(){ return this.shotgunLevel===1 ? CONFIG.player.shotgunFireRate : CONFIG.player.shotgunFireRate*1.5; }
    get missileCooldown(){ return [0,10,9,8,7,6,5,4,3,2,2][this.missileLevel]; }
    update(dt, game){
      const v = new Vec2(
        (Input.keys.has('a') || Input.keys.has('ArrowLeft')  ? -1 : 0) +
        (Input.keys.has('d') || Input.keys.has('ArrowRight') ?  1 : 0),
        (Input.keys.has('w') || Input.keys.has('ArrowUp')    ? -1 : 0) +
        (Input.keys.has('s') || Input.keys.has('ArrowDown')  ?  1 : 0)
      ); if (v.x||v.y) v.norm().scale(this.speed);
      this.vel = v; this.pos.add(this.vel.copy().scale(dt));
      const w = canvas.width, h = canvas.height;
      this.pos.x = clamp(this.pos.x, this.radius, w - this.radius);
      this.pos.y = clamp(this.pos.y, this.radius, h - this.radius);
      this.aim.set(Input.mouse.x - this.pos.x, Input.mouse.y - this.pos.y).norm();

      // Shooting
      this.shootCD -= dt; this.shotgunCD -= dt; this.missileCD -= dt;
      if (Input.mdown && this.shootCD <= 0 && this.machineLevel > 0) {
        this.shootCD = 1 / this.fireRate;
        this.shoot(game);
      }
      if (Input.mdown && this.shotgunCD <= 0 && this.shotgunLevel > 0) {
        this.shotgunCD = 1 / this.shotgunFireRate;
        this.shootShotgun(game);
      }
      if (this.missileCD <= 0 && this.missileLevel > 0) {
        this.missileCD = this.missileCooldown;
        this.shootMissile(game);
      }

      // Grenade
      if (Input.gdown) {
        Input.gdown = false;
        if (this.grenades > 0) this.throwGrenade(game); else showToast('No grenades!', 'warn');
      }
      if (this.invuln > 0) this.invuln -= dt;
    }
    shoot(game){
      const level = this.machineLevel;
      if (level <= 0) return;
      const baseSpeed = CONFIG.player.bulletSpeed;
      const speeds = { slow: baseSpeed*0.7, medium: baseSpeed, fast: baseSpeed*1.3 };
      const life = level === 1 ? 1.8 : 3.0;
      let speed = speeds.slow;
      let bullets = 1;
      let dmg = this.bulletDamage;
      let color = null;
      if (level === 3 || level === 6) speed = speeds.medium;
      if (level === 4 || level === 7 || level >= 9) speed = speeds.fast;
      if (level >= 5 && level <= 7) bullets = 2;
      if (level >= 8) bullets = 3;
      if (level === 10) { dmg *= 2; color = '#ff3030'; }
      const spread = 0.06;
      for (let i=0;i<bullets;i++){
        const ang = this.aim.angle() + (i-(bullets-1)/2)*spread;
        const vel = Vec2.fromAngle(ang, speed);
        game.spawnBullet(this.pos.x + this.aim.x*this.radius, this.pos.y + this.aim.y*this.radius, vel, dmg, ang, {life, color});
        spawnParticles(game, this.pos.x + this.aim.x*(this.radius+2), this.pos.y + this.aim.y*(this.radius+2), {
          angle: ang,
          spread: 0.2,
          count: 4,
          speed: [160, 260],
          life: [0.12, 0.2],
          colors: color ? [color, '#ffe8a8'] : ['#fffbd1', '#f8bd7f'],
          size: [1.6, 2.3]
        });
      }
      AudioBus.blip({freq: 720, dur:.03, vol:.12});
    }
    shootShotgun(game){
      const level = this.shotgunLevel;
      if (level <= 0) return;
      const baseSpeed = CONFIG.player.bulletSpeed*0.8;
      const life = level >= 9 ? 0.9 : 0.5;
      let front = 3, back = 0;
      if (level === 4) { front = 5; }
      if (level === 5) { front = 7; }
      if (level === 6) { front = 7; back = 3; }
      if (level === 7) { front = 7; back = 5; }
      if (level >= 8) { front = 7; back = 7; }
      const stun = level === 10 ? 1.5 : 0;
      const bulletColor = level === 10 ? '#ffff00' : '#ffffff';
      const spread = 0.18;
      for (let i=0;i<front;i++){
        const ang = this.aim.angle() + (i-(front-1)/2)*spread;
        const vel = Vec2.fromAngle(ang, baseSpeed);
        game.spawnBullet(this.pos.x + this.aim.x*this.radius, this.pos.y + this.aim.y*this.radius, vel, this.bulletDamage, ang, {life, color:bulletColor, stun});
        spawnParticles(game, this.pos.x + this.aim.x*(this.radius+2), this.pos.y + this.aim.y*(this.radius+2), {
          angle: ang,
          spread: 0.3,
          count: 5,
          speed: [140, 240],
          life: [0.1, 0.18],
          colors: [bulletColor, '#ffdba8'],
          size: [1.4, 2.1]
        });
      }
      if (back > 0){
        const base = this.aim.angle()+Math.PI;
        for (let i=0;i<back;i++){
          const ang = base + (i-(back-1)/2)*spread;
          const vel = Vec2.fromAngle(ang, baseSpeed);
          game.spawnBullet(this.pos.x - this.aim.x*this.radius, this.pos.y - this.aim.y*this.radius, vel, this.bulletDamage, ang, {life, color:bulletColor, stun});
          spawnParticles(game, this.pos.x - this.aim.x*(this.radius+2), this.pos.y - this.aim.y*(this.radius+2), {
            angle: ang,
            spread: 0.3,
            count: 4,
            speed: [120, 200],
            life: [0.1, 0.16],
            colors: [bulletColor, '#ffdba8'],
            size: [1.4, 2.1]
          });
        }
      }
      AudioBus.blip({freq: 520, dur:.05, vol:.15});
    }
    shootMissile(game){
      if (this.missileLevel <= 0) return;
      const level = this.missileLevel;
      const speed = CONFIG.player.bulletSpeed * (1.2 + 0.05 * (level - 1));
      const target = this.findMissileTarget(game);
      let launchDir = this.aim.copy();
      if (target) {
        const offset = target.pos.copy().sub(this.pos);
        const dist = offset.len();
        if (dist > 1e-3) {
          launchDir = offset.scale(1 / dist);
        }
      }
      let dirLength = launchDir.len();
      if (dirLength <= 1e-3) {
        launchDir = Vec2.fromAngle(this.aim.angle(), 1);
      } else if (Math.abs(dirLength - 1) > 1e-3) {
        launchDir.scale(1 / dirLength);
      }
      const angle = launchDir.angle();
      const vel = launchDir.copy().scale(speed);
      const opts = { missile: true, speed, target: target || null, seekTarget: true };
      if (level === 10) { opts.explosive = true; opts.glow = true; }
      game.spawnBullet(this.pos.x + launchDir.x*this.radius, this.pos.y + launchDir.y*this.radius, vel, this.bulletDamage*2, angle, opts);
      spawnParticles(game, this.pos.x + launchDir.x*(this.radius+4), this.pos.y + launchDir.y*(this.radius+4), {
        angle,
        spread: 0.18,
        count: 6,
        speed: [220, 320],
        life: [0.16, 0.26],
        colors: ['#aaffff', '#fff7d2'],
        size: [2.2, 3.2]
      });
      AudioBus.blip({freq: 300, dur:.08, vol:.2});
    }
    throwGrenade(game){
      this.grenades--;
      const g = new Grenade(
        this.pos.x + this.aim.x*(this.radius+6),
        this.pos.y + this.aim.y*(this.radius+6),
        this.aim.copy().scale(CONFIG.player.grenadeSpeed)
      );
      game.grenades.push(g); AudioBus.blip({freq: 200, dur:.06, vol:.18});
    }
    findMissileTarget(game){
      if (!game || !Array.isArray(game.enemies)) return null;
      const aimDir = this.aim.copy();
      let best = null;
      let bestDot = -Infinity;
      let bestDist = Infinity;
      for (const enemy of game.enemies) {
        if (!enemy || !enemy.alive) continue;
        const offset = enemy.pos.copy().sub(this.pos);
        const dist = offset.len();
        if (dist <= 1e-3) continue;
        const dir = offset.copy().scale(1 / dist);
        const dot = dir.x * aimDir.x + dir.y * aimDir.y;
        if (dot > bestDot + 1e-4 || (Math.abs(dot - bestDot) <= 1e-4 && dist < bestDist)) {
          best = enemy;
          bestDot = dot;
          bestDist = dist;
        }
      }
      return best;
    }
    healToFull(){ this.hp = this.maxHP; }
    draw(ctx, game){
      const a = this.aim.angle();
      ctx.save();
      ctx.globalAlpha = .18; ctx.fillStyle = "#000";
      ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+this.radius*.4, this.radius*1.2, this.radius*.7, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
      drawSprite(Sprites.player, this.pos.x, this.pos.y, a, this.radius/12);
      if (game.time % (1/this.fireRate) < .05 && Input.mdown) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(a);
        ctx.fillStyle = "#fff8a0"; ctx.fillRect(this.radius*1.35, -2, 10, 4); ctx.restore();
      }
      if (this.invuln > 0) {
        ctx.save();
        ctx.globalAlpha = clamp(this.invuln / CONFIG.player.invuln, 0, 1);
        ctx.strokeStyle = "#ff9b9b"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius+4, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }
  }

  class Grenade extends Entity {
    constructor(x, y, vel){ super(x,y, 6); this.vel = vel; this.fuse = CONFIG.player.grenadeFuse; this.exploded=false; }
    update(dt, game){
      this.pos.add(this.vel.copy().scale(dt)); this.vel.scale(0.96); this.fuse -= dt;
      if (!this.exploded && this.fuse <= 0) {
        this.exploded = true; this.alive = false;
        game.explode(this.pos.x, this.pos.y, CONFIG.player.grenadeRadius, CONFIG.player.grenadeDamage);
        AudioBus.boom({freq: 90, dur:.24, vol:.28});
      }
    }
    draw(ctx){ drawSprite(Sprites.grenade, this.pos.x, this.pos.y, 0, 1.6); }
  }

  class Particle extends Entity {
    constructor(x,y, vel, life, color, size){ super(x,y, size||2); this.vel=vel; this.life=life; this.color=color||'#fff'; }
    update(dt){ this.pos.add(this.vel.copy().scale(dt)); this.life -= dt; if (this.life <= 0) this.alive=false; }
    draw(ctx){ ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
      ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
  }

    const { Bullet, Missile } = createProjectileClasses(Entity, Vec2, Particle, rand, canvas);
    const Meteor = createMeteorClass(Entity, Vec2, Particle, rand, canvas);

  class Balloon extends Entity {
    constructor(x, y, color){
      super(x, y, 8);
      this.color = color || randBrightColor();
      this.drift = rand(-18, 18);
      this.speed = rand(62, 88);
      this.popped = false;
      if (typeof Balloon._nextId !== 'number') Balloon._nextId = 0;
      this.renderId = `balloon${Balloon._nextId++}`;
    }
    pop(game){
      if (this.popped) return;
      this.popped = true; this.alive = false;
      const burst = 20;
      for (let i=0;i<burst;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(100, 220);
        const c = Math.random() < 0.5 ? this.color : randBrightColor();
        game.particles.push(new Particle(this.pos.x, Math.max(0, this.pos.y), Vec2.fromAngle(ang, spd), .8, c, rand(1.2, 2.2)));
      }
      if (typeof AudioBus !== 'undefined' && AudioBus && typeof AudioBus.blip === 'function') {
        AudioBus.blip({freq: 920, dur:.03, vol:.16});
      }
    }
    update(dt, game){
      this.pos.y -= this.speed * dt;
      this.pos.x += this.drift * dt;
      // Pop at top edge and burst confetti
      if (!this.popped && this.pos.y <= -16) this.pop(game);
      // Safety cull in case no game passed
      if (this.pos.y < -64) this.alive = false;
    }
    draw(ctx){}
  }

  class FleeShadow extends Entity {
    constructor(x,y,type){
      super(x,y, 1);
      this.type = type;
      this.vel = new Vec2(rand(200,320), rand(-40,40));
      this.life = 1.6;
      if (typeof FleeShadow._nextId !== 'number') FleeShadow._nextId = 0;
      this.renderId = `flee${FleeShadow._nextId++}`;
    }
    update(dt){ this.pos.add(this.vel.copy().scale(dt)); this.life -= dt; if (this.life <= 0) this.alive=false; }
    draw(ctx){}
  }

  class Firework extends Entity {
    constructor(x, y, color){
      super(x, y, 3);
      this.color = color || randBrightColor();
      this.vel = new Vec2(rand(-30, 30), -rand(220, 300));
      this.fuse = rand(0.8, 1.4);
      this.trailTimer = 0;
      if (typeof Firework._nextId !== 'number') Firework._nextId = 0;
      this.renderId = `firework${Firework._nextId++}`;
    }
    update(dt, game){
      this.trailTimer -= dt;
      if (this.trailTimer <= 0) {
        this.trailTimer = 0.06;
        const trailV = Vec2.fromAngle(rand(Math.PI*0.9, Math.PI*1.1), rand(40, 90));
        game.particles.push(new Particle(this.pos.x, this.pos.y, trailV, 0.35, this.color, 1.4));
      }
      this.pos.add(this.vel.copy().scale(dt));
      this.vel.y += 30 * dt;
      this.fuse -= dt;
      const targetAlt = Math.max(60, canvas.height * 0.18);
      if (this.fuse <= 0 || this.pos.y <= targetAlt) {
        this.explode(game);
        this.alive = false;
      }
    }
    explode(game){
      const n = 36;
      for (let i=0;i<n;i++){
        const ang = (i/n) * Math.PI*2 + rand(-0.05, 0.05);
        const spd = rand(120, 260);
        const c = Math.random() < 0.5 ? this.color : randBrightColor();
        game.particles.push(new Particle(this.pos.x, this.pos.y, Vec2.fromAngle(ang, spd), .9, c, rand(1.4, 2.6)));
      }
      if (typeof AudioBus !== 'undefined' && AudioBus && typeof AudioBus.boom === 'function') {
        AudioBus.boom({freq: 140, dur:.12, vol:.22});
      }
    }
    draw(ctx){}
  }

  class Supply extends Entity {
    constructor(x,y,type){ super(x,y, 14); this.type=type; this.pulse=0; }
    apply(player){
      if (this.type==='grenade'){ const n=randi(1,2); player.grenades+=n; showToast(`+${n} grenade${n>1?'s':''}`); }
      else if (this.type==='machine'){ if (player.machineLevel < CONFIG.player.maxMachineLevel) { player.machineLevel++; showToast(`Machine upgraded ‚Üí Lv.${player.machineLevel}`, 'ok'); }
             else { player.grenades++; showToast('Max machine! +1 grenade','ok'); } }
      else if (this.type==='shotgun'){ if (player.shotgunLevel < CONFIG.player.maxShotgunLevel) { player.shotgunLevel++; showToast(`Shotgun upgraded ‚Üí Lv.${player.shotgunLevel}`, 'ok'); }
             else { player.grenades++; showToast('Max shotgun! +1 grenade','ok'); } }
      else if (this.type==='missile'){ if (player.missileLevel < CONFIG.player.maxMissileLevel) { player.missileLevel++; showToast(`Missiles upgraded ‚Üí Lv.${player.missileLevel}`, 'ok'); }
             else { player.grenades++; showToast('Max missiles! +1 grenade','ok'); } }
    }
    update(dt){ this.pulse += dt*2.2; }
    draw(ctx){
      const glow = (Math.sin(this.pulse)*0.5 + 0.5)*6 + 8;
      ctx.save(); ctx.globalAlpha = .18; ctx.fillStyle = this.type==='grenade' ? '#ffe59a' : this.type==='shotgun' ? '#ffa8e2' : this.type==='missile' ? '#a8ffa8' : '#a8d5ff';
      ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius+glow, 0, Math.PI*2); ctx.fill(); ctx.restore();
      drawSprite(this.type==='grenade'?Sprites.crateGren:this.type==='shotgun'?Sprites.crateShot:this.type==='missile'?Sprites.crateMiss:Sprites.crateGun, this.pos.x, this.pos.y, 0, 1.6);
    }
  }

  class Dino extends Entity {
    constructor(x,y,r,speed,hp,dmg){
      super(x,y,r);
      this.speed=speed; this.hp=hp; this.dmg=dmg;
      this.hitCD=0; this.hitFlash=0; this.stun=0;
    }
    damage(d){ this.hp -= d; this.hitFlash = .12; if (this.hp <= 0) this.alive = false; }
    hitPlayer(game, player, dt){
      if (this.hitCD>0) this.hitCD -= dt;
      if (boxHit(this, player)) {
        if (player.invuln<=0) {
          player.hp -= this.dmg; player.invuln = CONFIG.player.invuln;
          if (player.machineLevel > 1) { player.machineLevel--; showToast('Machine level lost', 'warn'); }
            if (player.shotgunLevel > 0) { player.shotgunLevel--; showToast('Shotgun level lost', 'warn'); }
            if (player.missileLevel > 0) { player.missileLevel--; showToast('Missile level lost', 'warn'); }
          AudioBus.boom({freq:120, dur:.09, vol:.18});
          for (let i=0;i<10;i++) game.particles.push(new Particle(player.pos.x, player.pos.y,
            Vec2.fromAngle(rand(0,Math.PI*2), rand(40,160)), .6, '#ff9b9b', 2));
          if (player.hp <= 0) game.gameOver();
        }
        const dir = player.pos.copy().sub(this.pos).norm(); player.pos.add(dir.scale(10));
      }
    }
  }

  const Raptor = createRaptorClass(Dino, Vec2);
  Raptor.prototype.draw = function(ctx){
    const a = this.vel.angle();
    ctx.save(); ctx.globalAlpha=.16; ctx.fillStyle="#000";
    ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+this.radius*.4, this.radius, this.radius*.6, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    drawSprite(Sprites.raptor, this.pos.x, this.pos.y, a, this.radius/12);
    if (this.hitFlash>0){ ctx.save(); ctx.globalAlpha = this.hitFlash*2; ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+3,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  };

  const WaterDino = createRaptorClass(Dino, Vec2);
  WaterDino.prototype.draw = function(ctx){
    const a = this.vel.angle();
    ctx.save(); ctx.globalAlpha=.16; ctx.fillStyle="#000";
    ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+this.radius*.4, this.radius, this.radius*.6, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    drawSprite(Sprites.waterdino, this.pos.x, this.pos.y, a, this.radius/12);
    if (this.hitFlash>0){ ctx.save(); ctx.globalAlpha = this.hitFlash*2; ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+3,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  };

  class Pterodactyl extends Dino {
    constructor(x,y, speed, hp, dmg){ super(x,y, CONFIG.enemies.ptero.radius, speed, hp, dmg); this.phase = rand(0, Math.PI*2); }
    update(dt, game){
      if (this.stun > 0) {
        this.stun -= dt;
        this.vel.set(0,0);
        this.hitFlash = Math.max(0, this.hitFlash - dt);
        return;
      }
      const dir = game.player.pos.copy().sub(this.pos).norm();
      const perp = new Vec2(-dir.y, dir.x).scale(Math.sin(game.time*2.1 + this.phase) * 0.6);
      const v = dir.add(perp).norm().scale(this.speed);
      this.vel = v; this.pos.add(this.vel.copy().scale(dt));
      this.hitPlayer(game, game.player, dt);
      this.hitFlash = Math.max(0, this.hitFlash - dt);
    }
    draw(ctx){
      const a = this.vel.angle();
      ctx.save(); ctx.globalAlpha=.14; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+this.radius*.5, this.radius*.9, this.radius*.5, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
      drawSprite(Sprites.ptero, this.pos.x, this.pos.y, a, this.radius/12);
      if (this.hitFlash>0){ ctx.save(); ctx.globalAlpha = this.hitFlash*2; ctx.fillStyle='#fff';
        ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+3,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    }
  }

  class TRex extends Dino {
    constructor(x,y, speed, hp, dmg){ super(x,y, CONFIG.enemies.trex.radius, speed, hp, dmg);
      this.isBoss = true; this.chargeCD = rand(...CONFIG.enemies.trex.chargeEvery); this.charging = 0; }
    update(dt, game){
      if (this.stun > 0) {
        this.stun -= dt;
        this.vel.set(0,0);
        this.hitFlash = Math.max(0, this.hitFlash - dt);
        return;
      }
      this.chargeCD -= dt;
      if (this.chargeCD <= 0 && this.charging <= 0) { this.charging = 1.2; this.chargeCD = rand(...CONFIG.enemies.trex.chargeEvery); }
      const dir = game.player.pos.copy().sub(this.pos).norm();
      let spd = this.speed; if (this.charging > 0) { this.charging -= dt; spd *= CONFIG.enemies.trex.chargeBoost; }
      this.vel = dir.scale(spd); this.pos.add(this.vel.copy().scale(dt));
      this.hitPlayer(game, game.player, dt);
      this.hitFlash = Math.max(0, this.hitFlash - dt);
    }
    draw(ctx){
      const a = this.vel.angle();
      ctx.save(); ctx.globalAlpha=.14; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+this.radius*.6, this.radius*1.2, this.radius*.7, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
      drawSprite(Sprites.trex, this.pos.x, this.pos.y, a, this.radius/24);
      if (this.charging>0){ ctx.save(); ctx.globalAlpha = .18; ctx.strokeStyle = "#ff9b9b"; ctx.lineWidth=8;
        ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+10,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
      if (this.hitFlash>0){ ctx.save(); ctx.globalAlpha = this.hitFlash*2; ctx.fillStyle='#fff';
        ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+6,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    }
  }

  class Mosasaurus extends TRex {}
  Mosasaurus.prototype.draw = function(ctx){
    const a = this.vel.angle();
    ctx.save(); ctx.globalAlpha=.14; ctx.fillStyle="#000";
    ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+this.radius*.6, this.radius*1.2, this.radius*.7, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    drawSprite(Sprites.mosasaurus, this.pos.x, this.pos.y, a, this.radius/24);
    if (this.charging>0){ ctx.save(); ctx.globalAlpha = .18; ctx.strokeStyle = "#ff9b9b"; ctx.lineWidth=8;
      ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+10,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    if (this.hitFlash>0){ ctx.save(); ctx.globalAlpha = this.hitFlash*2; ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius+6,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  };

  // -------------------------
  // Game orchestration
  // -------------------------
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function boxHit(a,b){
    const az = a.radius, bz = b.radius;
    return Math.abs(a.pos.x - b.pos.x) < az + bz &&
           Math.abs(a.pos.y - b.pos.y) < az + bz &&
           Math.abs((a.z||0) - (b.z||0)) < az + bz;
  }

  class Game {
    constructor(){ this.reset(); }
    reset(){
      this.time = 0; this.state = 'menu';
      this.player = new Player(canvas.width*0.5, canvas.height*0.6);
        this.bullets = []; this.enemies = []; this.grenades = []; this.supplies = []; this.particles = []; this.meteors = [];
        this.balloons = []; this.fleeShadows = []; this.fireworks = [];
      this.sceneIndex = 0;
      this.sceneTimer = 0;
      this.environment = SCENE_SEQUENCE[this.sceneIndex];
      this.scenery = [];
      this.groundBaseEnv = this.environment;
      this.nextGroundEnv = null;
      this.groundColumnStart = -1;
      this.groundGrid = createGroundTiles(this.groundBaseEnv, canvas.width, canvas.height, this.groundColumnStart, this.groundTileType.bind(this));
      this.nextGroundGrid = null;
      this.groundBlend = 0;
      this.groundBlendDuration = Math.max(1, canvas.width / CONFIG.scrollSpeed);
      this.groundScrollX = 0;
      renderer3D.updateGround(this.groundGrid, null, 0, this.groundScrollX);
      if (this.environment === 'forest') {
        this.seedForestTreesFromGrid(this.groundGrid);
      } else {
        this.scenery = generateScenery(40, canvas.width, canvas.height, this.environment);
      }
      // No water bubble effect in simplified water mode
      this.day = 1; this.dayTimer = 0; this.bossAlive = false; this.boss = null;
      this.enemySpawnCD = CONFIG.baseSpawnInterval; this.supplyCD = rand(...CONFIG.supplyEveryMinMax);
      this.highScore = Number(localStorage.getItem('dino_highscore') || 0);
      this.kills = 0; this.score = 0;
      this.specialCharge = 0; this.specialActive = false; this.specialTimer = 0; this.specialPulseTimer = 0; this.specialBirthday = false; this.specialBirthdayPulse = 0;
      updateHUD(this);
    }
    start(){ this.state='running'; hideOverlay(); showToast('Good luck, hunter!'); }
    gameOver(){
      if (this.state==='over') return; this.state='over'; saveHigh(this.score);
      showOverlay(`Game Over ‚Äî Day ${this.day}`, `<p>You scored <b>${Math.floor(this.score)}</b> with <b>${this.kills}</b> dinos downed.</p><p>Press <span class="key">R</span> to try again.</p>`);
      AudioBus.boom({freq:60, dur:.3, vol:.3});
    }
    explode(x,y, radius, damage, count=true){
      for (const e of this.enemies) {
        const d = dist({x,y}, e.pos);
        if (d < radius + e.radius) { e.damage(damage); if (!e.alive) this.onKill(e, !count); }
      }
      for (let i=0;i<38;i++) this.particles.push(new Particle(x,y, Vec2.fromAngle(rand(0,Math.PI*2), rand(80,320)), .8, '#ffd36b', 2));
    }
    onKill(e, fromSpecial=false){
      this.kills++; this.score += 10 * (e.isBoss ? 30 : 1) * this.day;
      if (!fromSpecial) this.specialCharge = Math.min(SPECIAL_CHARGE_REQUIRED, this.specialCharge + 1);
      if (!e.isBoss && Math.random()<0.08) this.dropSupply(e.pos.x, e.pos.y);
      const color = e.isBoss ? '#ffd0d0' : (e instanceof Pterodactyl ? '#9de0ff' : '#6fe27e');
      for (let i=0;i<14;i++) this.particles.push(new Particle(e.pos.x, e.pos.y,
        Vec2.fromAngle(rand(0,Math.PI*2), rand(60,200)), .7, color, 2));
    }
      laserBlast(){
        const w = canvas.width, h = canvas.height;
        if (!this.specialBirthday) {
          for (let i=0;i<5;i++) this.meteors.push(new Meteor(rand(0, w)));
          const x=this.player.pos.x, y=this.player.pos.y;
          for (const e of this.enemies) {
            if (!e.alive || e.isBoss) continue;
            e.damage(9999);
            if (!e.alive) this.onKill(e, true);
          }
          for (let i=0;i<36;i++) this.particles.push(new Particle(x,y, Vec2.fromAngle(i/36*Math.PI*2, 280), .4, '#ff7bff', 2));
          AudioBus.boom({freq:120, dur:.2, vol:.3});
          return;
        }

        this.specialBirthdayPulse = (this.specialBirthdayPulse || 0) + 1;
        const confettiColors = CELEBRATION_COLORS;
        const firstPulse = this.specialBirthdayPulse === 1;
        if (firstPulse) {
          // Firework bursts
          for (let b=0; b<3; b++){
            const fx = rand(w*0.15, w*0.85), fy = rand(h*0.25, h*0.55);
            for (let i=0;i<32;i++){
              const ang = rand(0, Math.PI*2);
              const spd = rand(120, 260);
              const col = confettiColors[(Math.random()*confettiColors.length)|0];
              this.particles.push(new Particle(fx, fy, Vec2.fromAngle(ang, spd), .75, col, rand(1.2,2.2)));
            }
          }
          // Confetti rain at top
          for (let r=0; r<40; r++){
            const cx = rand(0, w), cy = rand(0, h*0.35);
            const col = confettiColors[(Math.random()*confettiColors.length)|0];
            this.particles.push(new Particle(cx, cy, new Vec2(rand(-40,40), rand(60,140)), .8, col, rand(0.9,1.6)));
          }
          // Balloons rising ‚Äî 3D spheres, random bright colors
          for (let k=0; k<18; k++){
            const bx = rand(20, w-20), by = h + rand(20, 80);
            const col = randBrightColor();
            this.balloons.push(new Balloon(bx, by, col));
          }
          // Fireworks rockets rising from the bottom
          for (let r=0;r<2;r++){
            const fx = rand(40, w-40), fy = h + rand(10, 60);
            const col = randBrightColor();
            this.fireworks.push(new Firework(fx, fy, col));
          }
        } else {
          // Subsequent pulses: light sprinkle only
          for (let i=0;i<18;i++){
            const ang = rand(0, Math.PI*2);
            const spd = rand(80, 150);
            const col = confettiColors[(Math.random()*confettiColors.length)|0];
            this.particles.push(new Particle(this.player.pos.x, this.player.pos.y - 30, Vec2.fromAngle(ang, spd), .5, col, rand(0.9,1.6)));
          }
        }
        // Dinos flee and count as kills
        for (const e of this.enemies) {
          if (!e.alive || e.isBoss) continue;
          e.damage(9999);
          if (!e.alive) this.onKill(e, true);
        }
        // Cheerful blips on the first pulse only
        if (firstPulse) {
          AudioBus.blip({freq: 660, dur:.05, vol:.18});
          AudioBus.blip({freq: 880, dur:.05, vol:.18});
        }
        if (this.specialBirthdayPulse >= 3) this.specialBirthday = false;
      }
      showBirthdayBanner(){
        const existing = document.getElementById('bdayBanner');
        if (existing) {
          try { existing.remove(); } catch {}
        }
        const el = document.createElement('div');
        el.id = 'bdayBanner';
        el.className = 'bday-banner';
        el.textContent = 'Happy Birthday Eli!';
        el.style.opacity = '0';
        document.body.appendChild(el);
        requestAnimationFrame(()=>{ el.style.opacity = '1'; });
        setTimeout(()=>{ el.style.opacity = '0'; }, 2200);
        setTimeout(()=>{ try{el.remove();}catch{} }, 3200);
      }
    dropSupply(x,y){
      const r = Math.random();
      const type = r < 0.35 ? 'grenade' : r < 0.6 ? 'machine' : r < 0.85 ? 'shotgun' : 'missile';
      this.supplies.push(new Supply(x,y,type));
    }
    shiftGroundColumns(grid, env){
      if (!grid) return;
      grid.startCol += 1;
      const newWorldCol = grid.startCol + grid.cols - 1;
      for (let r = 0; r < grid.rows; r++) {
        const rowTiles = grid.tiles[r];
        rowTiles.shift();
        for (const tile of rowTiles) {
          tile.colIndex -= 1;
        }
        const worldRow = grid.startRow + r;
        const colIndex = grid.cols - 1;
        const type = this.groundTileType(env, newWorldCol, worldRow);
        const newTile = { colIndex, rowIndex: r, worldCol: newWorldCol, worldRow, type };
        rowTiles.push(newTile);
        this.maybeAddForestTreeForTile(newTile);
      }
    }
    groundTileType(env, worldCol, worldRow){
      return groundTypeForEnv(env, worldCol, worldRow);
    }
    prepareGroundTransition(nextEnv){ /* no-op (no-fade mode) */ }
    updateGroundBlend(dt){
      renderer3D.updateGround(this.groundGrid, null, 0, this.groundScrollX);
    }
    seedForestTreesFromGrid(grid){
      if (!grid) return;
      for (const row of grid.tiles) {
        for (const tile of row) {
          this.maybeAddForestTreeForTile(tile, true);
        }
      }
    }
    maybeAddForestTreeForTile(tile, initial=false){
      if (this.groundGrid?.env !== 'forest') return;
      if (tile.type !== 'grass') return;
      if (Math.random() >= FOREST_TREE_PROB) return;
      const offset = this.groundScrollX || 0;
      const tx = tile.colIndex * GROUND_TILE_SIZE + GROUND_TILE_SIZE / 2 - offset;
      const ty = tile.rowIndex * GROUND_TILE_SIZE + GROUND_TILE_SIZE / 2;
      const t = choice(['tree_oak', 'tree_pine', 'tree_birch']);
      this.scenery.push(new Scenery(tx, ty, t));
    }
    advanceScene(){
      this.sceneIndex = (this.sceneIndex + 1) % SCENE_SEQUENCE.length;
      const nextEnv = SCENE_SEQUENCE[this.sceneIndex];
      this.environment = nextEnv;
      this.groundGrid.env = nextEnv;
      this.groundBaseEnv = nextEnv;
      // Do not wipe scenery; let existing items scroll out naturally.
    }
    finalizeGroundTransition(){ /* no-op (no-fade mode) */ }
    handleResize(width, height){
      this.groundGrid = createGroundTiles(this.groundBaseEnv || this.environment, width, height, this.groundColumnStart, this.groundTileType.bind(this));
      renderer3D.updateGround(this.groundGrid, null, 0, this.groundScrollX);
      if (this.environment === 'forest') {
        this.scenery = [];
        this.seedForestTreesFromGrid(this.groundGrid);
      }
    }
    tileTypeAt(x, y){
      const grid = this.groundGrid; if (!grid) return null;
      const col = Math.floor(((x || 0) + (this.groundScrollX || 0)) / GROUND_TILE_SIZE);
      const row = Math.floor((y || 0) / GROUND_TILE_SIZE);
      if (row < 0 || row >= grid.rows) return null;
      if (col < 0 || col >= grid.cols) return null;
      const tile = grid.tiles[row]?.[col];
      return tile ? tile.type : null;
    }
    spawnBullet(x,y, vel, dmg, ang, opts={}){
      if (opts.missile) {
        const m = new Missile(x,y, vel, dmg, ang);
        if (typeof opts.speed === 'number' && Number.isFinite(opts.speed)) {
          m.baseSpeed = Math.max(Math.abs(opts.speed), 1);
          const currentLen = m.vel.len();
          if (currentLen > 1e-3) {
            m.vel.scale(m.baseSpeed / currentLen);
          } else {
            m.vel.set(Math.cos(ang), Math.sin(ang)).scale(m.baseSpeed);
          }
        }
        if (opts.target && opts.target.alive) {
          m.target = opts.target;
        } else if (opts.seekTarget) {
          m.target = m.findTarget(this);
        }
        if (!m.baseSpeed || !Number.isFinite(m.baseSpeed)) {
          m.baseSpeed = Math.max(m.vel.len(), 1);
        }
        if (typeof opts.turnRate === 'number' && Number.isFinite(opts.turnRate)) {
          m.turnRate = Math.min(Math.max(opts.turnRate, 0), 1);
        }
        if (opts.glow) m.glow = true;
        if (opts.explosive) m.explosive = true;
        this.bullets.push(m);
      } else this.bullets.push(new Bullet(x,y, vel, dmg, ang, opts.life, opts.radius, opts.color, opts.stun));
    }

    difficultyForDay(day, isBoss=false){
      const m = CONFIG.difficultyPerDay, n = day - 1;
      const scale = {
        hp: Math.pow(m.hp, n),
        speed: Math.pow(m.speed, n),
        dmg: Math.pow(m.dmg, n),
        spawnInterval: CONFIG.baseSpawnInterval / Math.pow(m.spawnRate, n)
      };
      if (isBoss) {
        const bossFactor = Math.pow(1.2, n);
        scale.hp *= bossFactor;
        scale.dmg *= bossFactor;
      }
      return scale;
    }

    spawnEnemy(){
      const w = canvas.width, h = canvas.height, m = CONFIG.worldMargin;
      const edge = choice(['top','bottom','left','right']); let x,y;
      if (edge==='top'){ x=rand(-m, w+m); y=-m; }
      else if (edge==='bottom'){ x=rand(-m, w+m); y=h+m; }
      else if (edge==='left'){ x=-m; y=rand(-m, h+m); }
      else { x=w+m; y=rand(-m, h+m); }

      const d = this.difficultyForDay(this.day);
      if (Math.random() < CONFIG.raptorBias){
        const base = CONFIG.enemies.raptor;
        if (this.environment === 'water') {
          this.enemies.push(new WaterDino(x,y, rand(...base.speed)*d.speed, Math.ceil(base.hp*d.hp), Math.ceil(base.dmg*d.dmg)));
        } else {
          this.enemies.push(new Raptor(x,y, rand(...base.speed)*d.speed, Math.ceil(base.hp*d.hp), Math.ceil(base.dmg*d.dmg)));
        }
      } else {
        const base = CONFIG.enemies.ptero;
        this.enemies.push(new Pterodactyl(x,y, rand(...base.speed)*d.speed, Math.ceil(base.hp*d.hp), Math.ceil(base.dmg*d.dmg)));
      }
    }

    spawnBoss(){
      const w = canvas.width, h = canvas.height, m = CONFIG.worldMargin;
      const side = choice(['top','bottom','left','right']); let x,y;
      if (side==='top'){ x=rand(m, w-m); y=-m; }
      else if (side==='bottom'){ x=rand(m, w-m); y=h+m; }
      else if (side==='left'){ x=-m; y=rand(m, h-m); }
      else { x=w+m; y=rand(m, h-m); }
      const d = this.difficultyForDay(this.day, true), base = CONFIG.enemies.trex;
      let boss;
      if (this.environment === 'water') {
        boss = new Mosasaurus(x,y, rand(...base.speed)*d.speed, Math.ceil(base.hp*d.hp), Math.ceil(base.dmg*d.dmg));
        showToast(`Day ${this.day} Boss: Mosasaurus`, 'danger');
      } else {
        boss = new TRex(x,y, rand(...base.speed)*d.speed, Math.ceil(base.hp*d.hp), Math.ceil(base.dmg*d.dmg));
        showToast(`Day ${this.day} Boss: T‚ÄëRex`, 'danger');
      }
      this.enemies.push(boss);
      this.boss = boss;
      this.bossAlive = true; AudioBus.roar();
    }

    update(dt){
      if (this.state !== 'running') return;

      this.time += dt;
      this.sceneTimer += dt;
      while (this.sceneTimer >= SCENE_DURATION) {
        this.sceneTimer -= SCENE_DURATION;
        this.advanceScene();
      }
      const dcfg = this.difficultyForDay(this.day);

      if (!this.bossAlive) {
        this.dayTimer += dt;
        if (this.dayTimer >= CONFIG.dayLength) this.spawnBoss();
      }

      if (!this.bossAlive) {
        this.enemySpawnCD -= dt;
        if (this.enemySpawnCD <= 0) { this.enemySpawnCD = dcfg.spawnInterval * rand(0.7, 1.3); this.spawnEnemy(); }
      }
      this.supplyCD -= dt;
      if (this.supplyCD <= 0) {
        this.supplyCD = rand(...CONFIG.supplyEveryMinMax);
        const ang = rand(0, Math.PI*2), r = rand(120, 280);
        const px = clamp(this.player.pos.x + Math.cos(ang)*r, 24, canvas.width-24);
        const py = clamp(this.player.pos.y + Math.sin(ang)*r, 24, canvas.height-24);
        this.dropSupply(px, py);
      }

      this.player.update(dt, this);
      if (Input.special) {
        Input.special = false;
        if (this.specialCharge >= SPECIAL_CHARGE_REQUIRED && !this.specialActive) {
          this.specialActive = true; this.specialTimer = 5; this.specialPulseTimer = 0; this.specialCharge = 0;
          this.specialBirthday = isEliBirthday();
          this.specialBirthdayPulse = 0;
          if (this.specialBirthday) {
            this.specialTimer = 3;
            this.showBirthdayBanner();
          }
        }
      }
      if (this.specialActive) {
        this.specialTimer -= dt; this.specialPulseTimer -= dt;
        if (this.specialPulseTimer <= 0 && this.specialTimer > 0) { this.specialPulseTimer += 1; this.laserBlast(); }
        if (this.specialTimer <= 0) this.specialActive = false;
      }

        for (const arr of [this.bullets, this.enemies, this.grenades, this.supplies, this.particles, this.meteors, this.balloons, this.fleeShadows, this.fireworks]) {
          if (!arr) continue;
          for (const e of arr) e.update?.(dt, this);
        }

      const scroll = CONFIG.scrollSpeed * dt;
      this.player.pos.x -= scroll;
      this.groundScrollX += scroll;
      let groundShifted = false;
      while (this.groundScrollX >= GROUND_TILE_SIZE) {
        this.groundScrollX -= GROUND_TILE_SIZE;
        this.groundColumnStart += 1;
        this.shiftGroundColumns(this.groundGrid, this.groundGrid.env);
        groundShifted = true;
      }
      if (groundShifted) {
        this.groundColumnStart = this.groundGrid.startCol;
        renderer3D.updateGround(this.groundGrid, null, 0, this.groundScrollX, true);
      }
      for (const arr of [this.bullets, this.enemies, this.grenades, this.supplies, this.particles, this.meteors, this.balloons, this.fleeShadows, this.fireworks]) {
        if (!arr) continue;
        for (const e of arr) e.pos.x -= scroll;
      }
      if (this.environment !== 'water') {
        scrollScenery(this.scenery, canvas.width, canvas.height, CONFIG.scrollSpeed, dt, Math.random, this.environment);
      } else if (this.scenery.length) {
        // Let leftover non-water scenery drift away without spawning new items
        scrollScenery(this.scenery, canvas.width, canvas.height, CONFIG.scrollSpeed, dt, Math.random, 'forest');
      }
      this.updateGroundBlend(dt);

      const blockingTrees = this.scenery.filter(s => SCENERY_MODELS[s.type]?.radius);

      // Bullet -> Enemy / Environment
      for (const b of this.bullets) {
        if (!b.alive) continue;
        for (const tree of blockingTrees) {
          const dxTree = b.pos.x - tree.x;
          const dyTree = b.pos.y - tree.y;
          const meta = SCENERY_MODELS[tree.type];
          const r = tree.radius || (meta && meta.radius) || TREE_COLLISION_RADIUS;
          if (dxTree * dxTree + dyTree * dyTree <= r * r) {
            b.alive = false;
            break;
          }
        }
        if (!b.alive) continue;
        for (const e of this.enemies) {
          if (!e.alive) continue;
          if (boxHit(b, e)) {
            if (b.explosive) {
              b.alive = false;
              this.explode(b.pos.x, b.pos.y, CONFIG.player.grenadeRadius, CONFIG.player.grenadeDamage);
              break;
            }
            b.alive = false; e.damage(b.dmg);
            if (b.stun) e.stun = Math.max(e.stun, b.stun);
            spawnParticles(this, b.pos.x, b.pos.y, {
              angle: b.vel.angle(),
              spread: 0.6,
              count: 6,
              speed: [90, 200],
              life: [0.18, 0.32],
              colors: ['#ffffff', '#ffce8a', '#ffe0ff'],
              size: [1.6, 2.6]
            });
            if (!e.alive) this.onKill(e); else e.pos.add(b.vel.copy().norm().scale(6));
            break;
          }
        }
      }

      // Bullet -> Balloons (shootable balloons)
      if (this.balloons && this.balloons.length) {
        for (const b of this.bullets) {
          if (!b.alive) continue;
          for (const bal of this.balloons) {
            if (!bal.alive) continue;
            if (boxHit(b, bal)) {
              b.alive = false;
              bal.pop(this);
              break;
            }
          }
        }
      }

      // Player -> Supply
      for (const s of this.supplies) {
        if (boxHit(s, this.player)) { s.alive = false; s.apply(this.player); AudioBus.blip({freq: 520, dur:.05, vol:.15}); }
      }

      // Cull
        this.bullets = (this.bullets||[]).filter(e => e.alive);
        this.enemies = (this.enemies||[]).filter(e => e.alive);
        this.grenades = (this.grenades||[]).filter(e => e.alive);
        this.supplies = (this.supplies||[]).filter(e => e.alive);
        this.particles = (this.particles||[]).filter(e => e.alive);
        this.meteors = (this.meteors||[]).filter(e => e.alive);
        this.balloons = (this.balloons||[]).filter(e => e.alive);
        this.fleeShadows = (this.fleeShadows||[]).filter(e => e.alive);
        this.fireworks = (this.fireworks||[]).filter(e => e.alive);
      if (this.particles.length > 300) {
        this.particles.splice(0, this.particles.length - 300);
      }
      if (this.balloons.length > 60) {
        this.balloons.splice(0, this.balloons.length - 60);
      }
      if (this.fireworks.length > 20) {
        this.fireworks.splice(0, this.fireworks.length - 20);
      }

      // Boss lifecycle
      if (this.bossAlive && (!this.boss || !this.boss.alive)) {
        this.bossAlive = false; this.boss = null; this.day++; this.dayTimer = 0; this.player.healToFull();
        showToast(`Day ${this.day} begins ‚Äî tougher foes ahead.`, 'ok'); AudioBus.blip({freq: 860, dur:.08, vol:.16});
      }

      this.score += dt * (2 * this.day);
      updateHUD(this);
    }

    render(){
      const w = canvas.width, h = canvas.height;
      if (renderer3D.renderer) renderer3D.renderer.setClearColor('#000000');
      renderer3D.beginFrame();
      renderer3D.hideWaterSurface();

      this.scenery.forEach((d,i)=>{
        const meta = SCENERY_MODELS[d.type];
        if (meta) {
          if (d.x > -100 && d.x < w + 100 && d.y > -100 && d.y < h + 100) {
            renderer3D.addVoxelModel(`scenery${i}`, meta.model, d.x, d.y, 0, meta.scale);
          }
        } else {
          const sprite = Sprites[d.type];
          if (sprite) renderer3D.addSprite(`scenery${i}`, sprite, d.x, d.y);
        }
      });

      this.supplies.forEach((s,i)=>{
      const color = s.type==='grenade' ? '#ffd36b' : s.type==='shotgun' ? '#ff64d2' : s.type==='missile' ? '#64ff64' : '#64d2ff';
      renderer3D.addCrate(`supply${i}`, s.pos.x, s.pos.y, color, this.time * 1000);
      });

      this.grenades.forEach((gr,i)=>renderer3D.addSprite(`grenade${i}`, Sprites.grenade, gr.pos.x, gr.pos.y, 0, 1.6));

      this.bullets.forEach((b,i)=>{
        const color = b.color ? parseInt(b.color.replace('#','0x')) : 0xe8f5ff;
        renderer3D.addSphere(`bullet${i}`, b.pos.x, b.pos.y, b.radius, color);
      });

      this.enemies.forEach((e,i)=>{
        const ang = e.vel.angle();
        let model = null;
        let scale = 1;
        if (e instanceof Raptor) { model = VOXEL_MODELS.raptor; scale = e.radius / 12; }
        else if (e instanceof WaterDino) { model = VOXEL_MODELS.water; scale = e.radius / 12; }
        else if (e instanceof Pterodactyl) { model = VOXEL_MODELS.ptero; scale = e.radius / 12; }
        else if (e instanceof Mosasaurus) { model = VOXEL_MODELS.mosasaurus; scale = (e.radius / 24) * 1.5; }
        else if (e instanceof TRex) { model = VOXEL_MODELS.trex; scale = (e.radius / 24) * 1.6; }
        if (model) {
          renderer3D.addVoxelModel(`enemy${i}`, model, e.pos.x, e.pos.y, ang, scale);
        }
      });

      this.meteors.forEach((m,i)=>renderer3D.addSprite(`meteor${i}`, Sprites.meteor, m.pos.x, m.pos.y, 0, m.radius/12));
      // 3D balloons: colored spheres with tiny bead-string
      if (this.balloons) {
        for (const b of this.balloons) {
          if (!b.renderId) {
            if (typeof Balloon._nextId !== 'number') Balloon._nextId = 0;
            b.renderId = `balloon${Balloon._nextId++}`;
          }
          const base = b.renderId;
          const color = typeof b.color === 'string' ? parseInt(b.color.replace('#','0x')) : (b.color||0xff4081);
          renderer3D.addSphere(`${base}:body`, b.pos.x, b.pos.y, 10, color);
          // bead-string below the balloon (3 small spheres)
          renderer3D.addSphere(`${base}:str0`, b.pos.x, b.pos.y + 10, 1, 0xc0c0c0);
          renderer3D.addSphere(`${base}:str1`, b.pos.x + 0.5, b.pos.y + 13, 1, 0xc0c0c0);
          renderer3D.addSphere(`${base}:str2`, b.pos.x - 0.5, b.pos.y + 16, 1, 0xc0c0c0);
        }
      }
      // rising fireworks rockets
      if (this.fireworks) {
        for (const f of this.fireworks) {
          if (!f.renderId) {
            if (typeof Firework._nextId !== 'number') Firework._nextId = 0;
            f.renderId = `firework${Firework._nextId++}`;
          }
          const color = typeof f.color === 'string' ? parseInt(f.color.replace('#','0x')) : (f.color||0xffffff);
          renderer3D.addSphere(`${f.renderId}:core`, f.pos.x, f.pos.y, 2.5, color);
        }
      }
      this.fleeShadows.forEach((f,i)=>{
        let model = null, scale = 1;
        if (f.type==='raptor') { model = VOXEL_MODELS.raptor; scale = 18/12; }
        else if (f.type==='water') { model = VOXEL_MODELS.water; scale = 18/12; }
        else if (f.type==='ptero') { model = VOXEL_MODELS.ptero; scale = 16/12; }
        if (model) {
          if (!f.renderId) {
            if (typeof FleeShadow._nextId !== 'number') FleeShadow._nextId = 0;
            f.renderId = `flee${FleeShadow._nextId++}`;
          }
          renderer3D.addVoxelModel(f.renderId, model, f.pos.x, f.pos.y, 0, scale);
        }
      });

      if (this.player) {
        const onWater = this.tileTypeAt(this.player.pos.x, this.player.pos.y) === 'water';
        if (onWater) {
          // Boat appears under the player when on a water tile
          renderer3D.addVoxelModel('boat', VOXEL_MODELS.boat, this.player.pos.x, this.player.pos.y + 4, 0, 2.4);
        }
        renderer3D.addVoxelModel('player', PLAYER_VOXEL_MODEL, this.player.pos.x, this.player.pos.y, this.player.aim.angle(), this.player.radius/12);
      }

      this.particles.forEach((p,i)=>{
        let color = 0xffffff;
        if (typeof p.color === 'string') {
          const hex = parseInt(p.color.replace('#','0x'));
          if (!Number.isNaN(hex)) color = hex;
        } else if (typeof p.color === 'number') {
          color = p.color;
        }
        const opacity = Math.max(0.1, Math.min(1, p.life));
        renderer3D.addBlock(`particle${i}`, p.pos.x, p.pos.y, color, p.radius*2, opacity);
      });

      // 3D edge fog: two bands ‚Äî positioned right at the border with minimal intrusion
      {
        const s = Math.floor(GROUND_TILE_SIZE * 2.6); // larger blocks for more height
        const half = s * 0.5;
        const inset = 12; // only this many pixels intrude into the playfield
        // Edge band sits almost off-screen; outside band is fully off-screen
        let i = 0;
        for (let y = -s; y <= h + s; y += s) {
          // Left side: outside + near-edge (barely inside)
          renderer3D.addBlock(`fogL_out_${i}`, -half - s + inset, y, 0x000000, s, 1.0);
          renderer3D.addBlock(`fogL_${i}`, -half + inset, y, 0x000000, s, 0.95);
          // Right side: near-edge (barely inside) + outside
          renderer3D.addBlock(`fogR_${i}`, w + half - inset, y, 0x000000, s, 0.95);
          renderer3D.addBlock(`fogR_out_${i}`, w + half + s - inset, y, 0x000000, s, 1.0);
          i++;
        }
        i = 0;
        for (let x = -s; x <= w + s; x += s) {
          // Top side: outside + near-edge
          renderer3D.addBlock(`fogT_out_${i}`, x, -half - s + inset, 0x000000, s, 1.0);
          renderer3D.addBlock(`fogT_${i}`, x, -half + inset, 0x000000, s, 1.0);
          // Bottom side: near-edge + outside
          renderer3D.addBlock(`fogB_${i}`, x, h + half - inset, 0x000000, s, 1.0);
          renderer3D.addBlock(`fogB_out_${i}`, x, h + half + s - inset, 0x000000, s, 1.0);
          i++;
        }
      }

      renderer3D.render();

      const boss = this.boss;
      const bossRow = document.getElementById('bossRow');
      if (boss) {
        bossRow.style.display = '';
        const bossbar = document.getElementById('bossbar');
        bossbar.style.width = `${clamp(boss.hp / (CONFIG.enemies.trex.hp * Math.pow(CONFIG.difficultyPerDay.hp, this.day-1)), 0, 1) * 100}%`;
      } else {
        bossRow.style.display = 'none';
      }
    }
  }

  // -------------------------
  // UI helpers
  // -------------------------
  function drawSprite(){ /* no-op in 3D mode */ }

  Bullet.prototype.draw = function(ctx){
    ctx.save();
    ctx.fillStyle = this.color || '#e8f5ff';
    if (this.color) {
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 8;
    }
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  };
  Missile.prototype.draw = function(ctx){
    ctx.save();
    ctx.translate(this.pos.x, this.pos.y);
    ctx.rotate(this.ang);
    ctx.fillStyle = this.glow ? '#00ff00' : '#e8f5ff';
    ctx.beginPath();
    ctx.moveTo(-this.radius, -this.radius/2);
    ctx.lineTo(this.radius, -this.radius/2);
    ctx.arc(this.radius, 0, this.radius/2, -Math.PI/2, Math.PI/2);
    ctx.lineTo(-this.radius, this.radius/2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  };

  // HUD elements ‚Äî DECLARE BEFORE new Game() is created
  const day       = document.getElementById('day');
  const kills     = document.getElementById('kills');
  const score     = document.getElementById('score');
  const grenades  = document.getElementById('grenades');
  const machlvl   = document.getElementById('machlvl');
  const shotlvl   = document.getElementById('shotlvl');
  const misslvl   = document.getElementById('misslvl');
  const daybar    = document.getElementById('daybar');
  const timeleft  = document.getElementById('timeleft');
    const hpbar     = document.getElementById('hpbar');
    const hptext    = document.getElementById('hptext');
    const spbar     = document.getElementById('spbar');

  function updateHUD(game){
    day.textContent = game.day;
    kills.textContent = game.kills;
    score.textContent = Math.floor(game.score);
    grenades.textContent = game.player.grenades;
    machlvl.textContent = game.player.machineLevel;
    shotlvl.textContent = game.player.shotgunLevel;
    misslvl.textContent = game.player.missileLevel;
      daybar.style.width = `${clamp(game.dayTimer / CONFIG.dayLength, 0, 1) * 100}%`;
      timeleft.textContent = game.bossAlive ? 'Boss!' : `${Math.max(0, Math.ceil(CONFIG.dayLength - game.dayTimer))}s`;
      hpbar.style.width = `${clamp(game.player.hp / game.player.maxHP, 0, 1) * 100}%`;
      hptext.textContent = Math.max(0, Math.ceil(game.player.hp));
      spbar.style.width = `${clamp(game.specialCharge / SPECIAL_CHARGE_REQUIRED, 0, 1) * 100}%`;
      spbar.style.background = specialBarColor(game.specialCharge, SPECIAL_CHARGE_REQUIRED);
  }

  const overlay = document.getElementById('overlay');
  function hideOverlay(){ overlay.classList.add('hidden'); }
  function showOverlay(title, innerHTML){
    overlay.innerHTML = `<div class="card"><h2>${title}</h2>${innerHTML||''}<div class="cta-row"><button id="btnRestart" class="cta">‚Üª Restart</button></div></div>`;
    overlay.classList.remove('hidden');
    overlay.querySelector('#btnRestart')?.addEventListener('click', () => restart());
  }

  const toastWrap = document.getElementById('toast');
  function showToast(msg, kind){
    const el = document.createElement('div'); el.className = `toast ${kind||''}`; el.textContent = msg;
    toastWrap.appendChild(el); setTimeout(() => { el.style.opacity='0'; el.style.transform='translateX(12px)'; }, 1600);
    setTimeout(() => el.remove(), 1900);
  }
  function saveHigh(score){
    const hi = Number(localStorage.getItem('dino_highscore') || 0);
    if (score > hi) { localStorage.setItem('dino_highscore', String(Math.floor(score))); showToast(`New High Score: ${Math.floor(score)}!`, 'ok'); }
  }

  // -------------------------
  // Game loop & controls  (SINGLE COPY)
  // -------------------------
  game = new Game();
  let last = now();

  function frame(){
    const t = now();
    let dt = (t - last) / 1000;
    dt = Math.min(dt, 1/20);
    game.update(dt);
    game.render();
    last = now();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function restart(){ game.reset(); game.start(); }
  function togglePause(){ if (game.state==='running') { game.state='paused'; showToast('Paused'); } else if (game.state==='paused') { game.state='running'; showToast('Resumed'); } }
  function toggleFullscreen(){ if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen().catch(()=>{}); }
  function startGame(){ game.start(); AudioBus.ensure(); }

  document.getElementById('btnStart').addEventListener('click', startGame);
  document.getElementById('btnMute').addEventListener('click', toggleMute);
  document.getElementById('btnFS').addEventListener('click', toggleFullscreen);

  document.addEventListener('keydown', (e) => {
    if (!overlay.classList.contains('hidden') && (e.key === 'Enter' || e.key === ' ')) {
      e.preventDefault(); startGame();
    }
  });

  window.addEventListener('blur', () => { if (game.state==='running') togglePause(); });

  window.addEventListener('resize', () => {
    game.player.pos.x = Math.max(game.player.radius, Math.min(canvas.width - game.player.radius, game.player.pos.x));
    game.player.pos.y = Math.max(game.player.radius, Math.min(canvas.height - game.player.radius, game.player.pos.y));
  });
  </script>
    
</body>
</html>
